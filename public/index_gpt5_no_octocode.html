<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Octopus Ocean â€¢ Three.js (single file)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      /* Minimal CSS: canvas fills the viewport */
      html, body {
        margin: 0;
        padding: 0;
        height: 100%;
        overflow: hidden;
        background: #0c1f2a; /* matches fog/sea tones */
      }
      canvas {
        display: block;
        width: 100%;
        height: 100%;
      }
    </style>
    <!-- Import map pins both three and its addons to the same CDN and version -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <script type="module">
      // Import Three.js and OrbitControls via import map (same CDN + version)
      import * as THREE from 'three';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

      // ----- Renderer -----
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      document.body.appendChild(renderer.domElement);

      // ----- Scene -----
      const scene = new THREE.Scene();
      const fogColor = new THREE.Color(0x0f3040);
      scene.background = fogColor.clone();
      scene.fog = new THREE.FogExp2(fogColor.getHex(), 0.025); // subtle ocean haze

      // ----- Camera + Controls -----
      const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(4, 2.2, 4.5);
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.target.set(0, 0.6, 0); // look at the octopus
      controls.update();

      // ----- Lights (soft lighting) -----
      // Hemisphere light for ambient sky-ocean tone
      const hemi = new THREE.HemisphereLight(0x87b5ff, 0x174a55, 0.65);
      scene.add(hemi);
      // Directional light for soft highlights
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(5, 8, 3);
      scene.add(dirLight);

      // ----- Water surface (procedural, no external textures) -----
      // Large plane with lightweight vertex displacement in shader
      const waterSize = 200;
      const waterSegs = 96;
      const waterGeo = new THREE.PlaneGeometry(waterSize, waterSize, waterSegs, waterSegs);
      const waterMat = new THREE.MeshStandardMaterial({
        color: new THREE.Color(0x145a73), // deep teal
        metalness: 0.05,
        roughness: 0.8,
        transparent: true,
        opacity: 0.98
      });
      let waterShader = null;
      waterMat.onBeforeCompile = (shader) => {
        // Uniforms to animate gentle waves
        shader.uniforms.uTime = { value: 0 };
        shader.uniforms.uAmp = { value: 0.35 };
        shader.uniforms.uFreq = { value: 0.9 };
        shader.uniforms.uSpeed = { value: 0.6 };
        shader.vertexShader = shader.vertexShader
          .replace(
            '#include <common>',
            `
            #include <common>
            uniform float uTime;
            uniform float uAmp;
            uniform float uFreq;
            uniform float uSpeed;
            `
          )
          .replace(
            // Displace along local Z (plane is XY by default; mesh is rotated to lie horizontally)
            '#include <begin_vertex>',
            `
            #include <begin_vertex>
            float wave = sin((position.x + position.y) * uFreq * 0.3 + uTime * uSpeed)
                       + 0.5 * sin((position.x - position.y) * uFreq * 0.55 - uTime * (uSpeed * 1.3));
            transformed.z += uAmp * wave * 0.5;
            `
          );
        // Slight color variation with view angle for a subtle fresnel-like effect
        shader.fragmentShader = shader.fragmentShader
          .replace(
            '#include <output_fragment>',
            `
            // faint horizon brightening
            float vdot = dot(normalize(vNormal), normalize(-vViewPosition));
            float fres = pow(1.0 - saturate(vdot), 2.0) * 0.15;
            gl_FragColor.rgb += fres;
            #include <output_fragment>
            `
          );

        waterShader = shader; // store so we can update time
      };
      const water = new THREE.Mesh(waterGeo, waterMat);
      water.rotation.x = -Math.PI * 0.5;
      water.position.y = 0.0;
      water.receiveShadow = false;
      scene.add(water);

      // ----- Octopus (basic geometries, no external models) -----
      const octopus = new THREE.Group();
      scene.add(octopus);

      // Body: stretched sphere with rim-light effect via onBeforeCompile
      const bodyGeo = new THREE.SphereGeometry(0.6, 32, 24);
      const bodyMat = new THREE.MeshStandardMaterial({
        color: new THREE.Color(0xff77aa), // pink
        metalness: 0.05,
        roughness: 0.6,
        emissive: new THREE.Color(0x000000)
      });
      bodyMat.onBeforeCompile = (shader) => {
        shader.uniforms.uRimColor = { value: new THREE.Color(0xffe6ff) };
        shader.uniforms.uRimStrength = { value: 0.7 };
        shader.fragmentShader = shader.fragmentShader
          .replace(
            '#include <common>',
            `
            #include <common>
            uniform vec3 uRimColor;
            uniform float uRimStrength;
            `
          )
          .replace(
            '#include <emissivemap_fragment>',
            `
            #include <emissivemap_fragment>
            // Rim-light: brighter on grazing angles, adds to emissive so it remains soft
            float rim = 1.0 - saturate(dot(normalize(vNormal), normalize(-vViewPosition)));
            rim = pow(rim, 2.0);
            totalEmissiveRadiance += uRimColor * rim * uRimStrength;
            `
          );
      };
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.scale.set(1.0, 1.15, 1.0); // slightly taller
      body.position.y = 0.8;
      octopus.add(body);

      // Eyes: tiny spheres (basic geometry)
      const eyeMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.5, metalness: 0.0 });
      const eyeGeo = new THREE.SphereGeometry(0.05, 12, 10);
      const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
      const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
      eyeL.position.set(0.18, 0.93, 0.46);
      eyeR.position.set(-0.18, 0.93, 0.46);
      body.add(eyeL, eyeR);

      // Tentacles: 8 chains of lightweight cylinder segments animated by phase-shifted sine waves
      const tentacles = []; // store chains for animation
      const tentacleCount = 8;
      const segmentCount = 12;
      const segmentLength = 0.22;
      const baseRadius = 0.12;

      function createTentacleChain() {
        // Root object for the tentacle chain
        const root = new THREE.Object3D();
        const joints = [];
        let parent = root;

        // Pinkish tentacle material (reuse body color family)
        const tMaterial = new THREE.MeshStandardMaterial({
          color: new THREE.Color(0xff88bb),
          metalness: 0.05,
          roughness: 0.65
        });

        for (let i = 0; i < segmentCount; i++) {
          const t = 1 - i / (segmentCount - 1);
          const rTop = baseRadius * (0.55 + 0.45 * t) * 0.9;
          const rBottom = baseRadius * (0.45 + 0.35 * t) * 0.9;

          // Cylinder aligned along Y; we'll hinge at the top by offsetting the mesh
          const geo = new THREE.CylinderGeometry(rTop, rBottom, segmentLength, 8, 1, true);
          const joint = new THREE.Object3D();
          const mesh = new THREE.Mesh(geo, tMaterial);
          mesh.position.y = -segmentLength * 0.5; // pivot at the segment's top
          joint.add(mesh);

          parent.add(joint);
          joints.push(joint);

          // Next joint starts at end of this segment
          const next = new THREE.Object3D();
          next.position.y = -segmentLength;
          joint.add(next);
          parent = next;
        }
        return { root, joints };
      }

      // Arrange 8 tentacles around the body base
      const radiusAround = 0.45;
      for (let i = 0; i < tentacleCount; i++) {
        const angle = (i / tentacleCount) * Math.PI * 2;
        const base = new THREE.Object3D();
        base.position.set(Math.cos(angle) * radiusAround, 0.65, Math.sin(angle) * radiusAround);
        base.rotation.y = angle + Math.PI * 0.5; // face outward
        base.rotation.x = THREE.MathUtils.degToRad(12); // slight outward tilt
        octopus.add(base);

        const { root, joints } = createTentacleChain();
        base.add(root);
        tentacles.push({ base, joints, baseAngle: angle });
      }

      // ----- Animation state -----
      const clock = new THREE.Clock();
      let tAccum = 0;

      // ----- Resize handling -----
      function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      window.addEventListener('resize', onResize);

      // ----- Main loop -----
      function animate() {
        const dt = clock.getDelta();
        tAccum += dt;

        // Animate water time uniform
        if (waterShader) {
          waterShader.uniforms.uTime.value = tAccum;
        }

        // Gentle bobbing/swim motion for the octopus body
        const swim = Math.sin(tAccum * 1.2) * 0.06;
        octopus.position.y = 0.25 + swim * 0.4;
        octopus.position.x = Math.sin(tAccum * 0.25) * 0.15;
        octopus.position.z = Math.cos(tAccum * 0.22) * 0.15;
        octopus.rotation.y = Math.sin(tAccum * 0.5) * 0.2;

        // Tentacle animation: phase-shifted sine along each chain
        const waveSpeed = 2.2;
        const segPhase = 0.6;
        for (let idx = 0; idx < tentacles.length; idx++) {
          const { joints, baseAngle } = tentacles[idx];
          const basePhase = baseAngle * 1.2; // shift per tentacle around the body
          for (let s = 0; s < joints.length; s++) {
            const joint = joints[s];
            const falloff = 1.0 - s / joints.length;
            const amp = 0.35 * Math.pow(falloff, 0.7); // taper amplitude
            const phase = waveSpeed * tAccum + basePhase + s * segPhase;

            // Bend primarily around Z, with a slight X component for 3D motion
            joint.rotation.z = amp * Math.sin(phase);
            joint.rotation.x = 0.35 * amp * Math.cos(phase * 0.9);
          }
        }

        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }

      // Small helper: show the octopus slightly above water for clarity
      octopus.position.y = 0.25;

      // Start!
      animate();
    </script>
  </body>
  </html>
