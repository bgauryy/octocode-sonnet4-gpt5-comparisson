<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pink Octopus in an Ocean - Three.js (ESM)</title>
<style>
html, body { height: 100%; margin: 0; background: #072136; color: #cfe7ff; }
body { overflow: hidden; }
canvas { display: block; }
.overlay { position: fixed; left: 12px; bottom: 12px; font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif; opacity: 0.75; pointer-events: none; user-select: none; }
</style>
<!-- Import map to resolve module specifiers to CDN URLs (pinned to latest) -->
<script type="importmap">
{
"imports": {
"three": "https://unpkg.com/three@latest/build/three.module.js",
"three/addons/": "https://unpkg.com/three@latest/examples/jsm/"
}
}
</script>
</head>
<body>
<div class="overlay">Drag to orbit â€¢ Scroll to zoom</div>
<script type="module">
// Core imports from the import map (ES modules, no build tools)
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
// Renderer
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
document.body.appendChild(renderer.domElement);
// Scene and subtle ocean fog
const scene = new THREE.Scene();
const oceanColor = new THREE.Color(0x0a2a3f);
scene.background = oceanColor.clone();
scene.fog = new THREE.FogExp2(oceanColor.getHex(), 0.018);
// Camera
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(6, 3.5, 8);
// Camera orbit interaction
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.target.set(0, 1.0, 0);
controls.maxPolarAngle = Math.PI * 0.95;
controls.minDistance = 2.5;
controls.maxDistance = 25;
// Soft lighting: hemisphere + directional
const hemiLight = new THREE.HemisphereLight(0x87bff5, 0x0d2030, 0.75);
scene.add(hemiLight);
const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
dirLight.position.set(-5, 8, 4);
scene.add(dirLight);
// --- Ocean surface (vertex shader waves + recomputed normals; no external textures) ---
const oceanSize = 500;
const oceanSegments = 200; // moderate for performance
const waterGeo = new THREE.PlaneGeometry(oceanSize, oceanSize, oceanSegments, oceanSegments);
waterGeo.rotateX(-Math.PI / 2);
const waterMat = new THREE.MeshStandardMaterial({
color: new THREE.Color(0x0c4a66).lerp(new THREE.Color(0x0a2f49), 0.25),
roughness: 0.35,
metalness: 0.05,
envMapIntensity: 0.6,
fog: true
});
// Wave uniforms
const waterUniforms = {
uTime: { value: 0 },
uWaveDir1: { value: new THREE.Vector2(1.0, 0.2).normalize() },
uWaveDir2: { value: new THREE.Vector2(-0.3, 1.0).normalize() },
uAmp1: { value: 0.18 },
uAmp2: { value: 0.10 },
uFreq1: { value: 0.18 },
uFreq2: { value: 0.11 },
uSpeed1: { value: 0.6 },
uSpeed2: { value: 0.45 }
};
waterMat.onBeforeCompile = (shader) => {
// Inject uniforms
Object.assign(shader.uniforms, waterUniforms);
shader.vertexShader = shader.vertexShader
    .replace(
      '#include <common>',
      `#include <common>
uniform float uTime;
uniform vec2 uWaveDir1; uniform vec2 uWaveDir2;
uniform float uAmp1; uniform float uAmp2;
uniform float uFreq1; uniform float uFreq2;
uniform float uSpeed1; uniform float uSpeed2;`
    )
    // Recompute the geometric normal based on wave gradient for better lighting
    .replace(
      '#include <beginnormal_vertex>',
      `#include <beginnormal_vertex>
vec2 p_n = position.xz;
vec2 d1 = normalize(uWaveDir1);
vec2 d2 = normalize(uWaveDir2);
float t1 = uFreq1 * dot(p_n, d1) + uSpeed1 * uTime;
float t2 = uFreq2 * dot(p_n, d2) + uSpeed2 * uTime;
vec2 grad = cos(t1) * uAmp1 * uFreq1 * d1 + cos(t2) * uAmp2 * uFreq2 * d2;
objectNormal = normalize(vec3(-grad.x, 1.0, -grad.y));`
    )
    // Displace the surface along Y using two sine waves
    .replace(
      '#include <begin_vertex>',
      `vec3 transformed = vec3( position );
vec2 p = transformed.xz;
vec2 d1b = normalize(uWaveDir1);
vec2 d2b = normalize(uWaveDir2);
float h = sin(uFreq1 * dot(p, d1b) + uSpeed1 * uTime) * uAmp1
        + sin(uFreq2 * dot(p, d2b) + uSpeed2 * uTime) * uAmp2;
transformed.y += h;`
    );
};
const water = new THREE.Mesh(waterGeo, waterMat);
water.receiveShadow = false;
scene.add(water);
// --- Utility: add simple rim-light effect to a MeshStandardMaterial via emissive injection ---
const rimUniforms = {
uRimColor: { value: new THREE.Color(0xffa8d9) },
uRimIntensity: { value: 0.8 },
uRimPower: { value: 2.0 }
};
      const addRimToMaterial = (mat) => {
        const prev = mat.onBeforeCompile;
        mat.onBeforeCompile = (shader) => {
          if (prev) prev(shader);
          Object.assign(shader.uniforms, rimUniforms);

          // Vertex: declare and write view-space normal for rim calculation
          shader.vertexShader = shader.vertexShader
            .replace(
              '#include <common>',
              `#include <common>
varying vec3 vRimNormal;`
            )
            .replace(
              '#include <beginnormal_vertex>',
              `#include <beginnormal_vertex>
vRimNormal = normalize( normalMatrix * objectNormal );`
            );

          // Fragment: declare uniforms and varying, then add rim to emissive
          shader.fragmentShader = shader.fragmentShader
            .replace(
              '#include <common>',
              `#include <common>
varying vec3 vRimNormal;
uniform vec3 uRimColor;
uniform float uRimIntensity;
uniform float uRimPower;`
            )
            .replace(
              'vec3 totalEmissiveRadiance = emissive;',
              `vec3 totalEmissiveRadiance = emissive;
// Rim light based on view angle using view-space normal
vec3 V = normalize(-vViewPosition);
float rim = pow(1.0 - saturate(dot(normalize(vRimNormal), V)), uRimPower) * uRimIntensity;
totalEmissiveRadiance += uRimColor * rim;`
            );
        };
      };
// --- Octopus construction (body + eyes + 8 animated tentacles) ---
const octopus = new THREE.Group();
scene.add(octopus);
// Body: pink sphere with rim-lit standard material
const pink = new THREE.Color(0xff6fb5);
const bodyMat = new THREE.MeshStandardMaterial({
color: pink,
roughness: 0.6,
metalness: 0.0,
emissive: 0x000000
});
addRimToMaterial(bodyMat);
const body = new THREE.Mesh(new THREE.SphereGeometry(1.0, 32, 24), bodyMat);
body.position.y = 1.4; // lift above water a bit
octopus.add(body);
// Eyes: two white spheres with black pupils
const eyeWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.35, metalness: 0.0 });
const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.6, metalness: 0.0 });
const makeEye = (x) => {
const eye = new THREE.Group();
const sclera = new THREE.Mesh(new THREE.SphereGeometry(0.18, 20, 16), eyeWhiteMat);
const pupil = new THREE.Mesh(new THREE.SphereGeometry(0.08, 16, 12), pupilMat);
pupil.position.z = 0.12; // small bulge forward
eye.add(sclera, pupil);
eye.position.set(x, 1.65, 0.88);
return eye;
};
octopus.add(makeEye(-0.35), makeEye(0.35));
// Tentacles: 8 animated cylinders with shader-based bending (no bones, light-weight)
const tentacleCount = 8;
const tentacles = [];
const tentacleLen = 2.3;
const tentacleGeo = new THREE.CylinderGeometry(0.23, 0.06, tentacleLen, 12, 60, true);
tentacleGeo.translate(0, tentacleLen * 0.5, 0); // base at y=0
const baseTentacleMat = new THREE.MeshStandardMaterial({
color: pink.clone().multiplyScalar(0.98),
roughness: 0.65,
metalness: 0.0
});
const tentacleUniforms = {
uTime: { value: 0 },
uAmp: { value: 0.22 },
uFreq: { value: 3.0 },
uSpeed: { value: 1.6 },
uPhase: { value: 0 }, // per-instance phase
uLen: { value: tentacleLen }
};
// Arrange 8 tentacles around the body
for (let i = 0; i < tentacleCount; i++) {
const mat = baseTentacleMat.clone();
// Per-tentacle bending shader
mat.onBeforeCompile = (shader) => {
if (!shader.uniforms.uTime) Object.assign(shader.uniforms, JSON.parse(JSON.stringify(tentacleUniforms)));
shader.vertexShader = shader.vertexShader
.replace(
'#include <common>',
    `#include <common>
uniform float uTime, uAmp, uFreq, uSpeed, uPhase, uLen;`
)
.replace(
'#include <begin_vertex>',
    `vec3 transformed = vec3( position );
float t = clamp(transformed.y / max(uLen, 1e-3), 0.0, 1.0); // 0 at base, 1 at tip
// Gentle taper along the length
float taper = mix(1.0, 0.35, t);
transformed.xz *= taper;
// Dual-axis sinusoidal bending, diminishing toward the base
float phase = uFreq * t + (uTime * uSpeed) + uPhase;
float bendX = sin(phase) * uAmp * (1.0 - pow(t, 0.65));
float bendZ = cos(phase * 0.8 + 1.57) * (uAmp * 0.7) * (1.0 - pow(t, 0.65));
transformed.x += bendX;
transformed.z += bendZ;`
);
// store shader for runtime uniform updates
mat.userData.shader = shader;
};
// Add rim after bending injection to compose effects
addRimToMaterial(mat);
const mesh = new THREE.Mesh(tentacleGeo, mat);
// position around a ring at the bottom of the body
const angle = (i / tentacleCount) * Math.PI * 2;
const radius = 0.75;
const baseX = Math.cos(angle) * radius;
const baseZ = Math.sin(angle) * radius;
        mesh.position.set(baseX, 1.0, baseZ); // attach closer to body underside
        mesh.rotation.y = angle + Math.PI * 0.5; // face outward a bit
        mesh.rotation.x = Math.PI; // flip so tentacle extends downward
// Per-tentacle phase to de-sync motion
mesh.onBeforeRender = (r, _s, _c, _g, material) => {
const shader = material.userData && material.userData.shader;
if (shader) {
shader.uniforms.uPhase.value = i * 0.6;
shader.uniforms.uLen.value = tentacleLen;
}
};
tentacles.push(mesh);
octopus.add(mesh);
}
// Gentle swim motion across the ocean
let swimDir = 1;
const swimBounds = 12;
octopus.position.set(-swimBounds, 0.0, 0);
// Clock for animation timing
const clock = new THREE.Clock();
let lastTime = 0;
// Resize handling (responsive canvas)
window.addEventListener('resize', () => {
const w = window.innerWidth, h = window.innerHeight;
renderer.setSize(w, h);
camera.aspect = w / h;
camera.updateProjectionMatrix();
});
// Animation loop (~60 FPS on typical laptop)
function animate() {
const t = clock.getElapsedTime();
const dt = t - lastTime;
lastTime = t;
// Update water time
waterUniforms.uTime.value = t;
// Update tentacle uniforms
for (const ten of tentacles) {
const mat = ten.material;
const shader = mat.userData && mat.userData.shader;
if (shader) {
shader.uniforms.uTime.value = t;
shader.uniforms.uAmp.value = 0.22 + Math.sin(t * 1.1) * 0.03; // subtle variation
shader.uniforms.uFreq.value = 3.0;
shader.uniforms.uSpeed.value = 1.6;
}
}
// Octopus swim and bobbing
octopus.position.x += 0.6 * dt * swimDir; // units per second
octopus.position.y = 0.4 + Math.sin(t * 1.5) * 0.2;
octopus.rotation.y = Math.sin(t * 0.3) * 0.15 + (swimDir > 0 ? 0 : Math.PI);
body.rotation.z = Math.sin(t * 1.7) * 0.05; // subtle wobble
if (octopus.position.x > swimBounds) { swimDir = -1; }
if (octopus.position.x < -swimBounds) { swimDir = 1; }
controls.update();
renderer.render(scene, camera);
requestAnimationFrame(animate);
}
// Pre-warm: compile materials to avoid first-frame hitches
renderer.compile(scene, camera);
animate();
</script>
</body>
</html>